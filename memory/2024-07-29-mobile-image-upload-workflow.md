****# Mobile Image Upload Workflow (Offline-First)

This document outlines the process for uploading images from the Note Companion mobile app, based on the implementation in `packages/mobile/utils/file-handler.ts`. The system uses an offline-first approach, queuing files locally before uploading them in the background.

## Workflow Steps

1.  **Initiation & Local Save (`handleSharedFile` -> `saveFileLocally`):**
    *   User shares an image to the app.
    *   A unique `localId` (e.g., `local-timestamp-random`) is generated.
    *   A dedicated directory is created: `[FileSystem.documentDirectory]/pending_uploads/{localId}/`.
    *   The original image file is copied into this directory.
    *   A thumbnail preview is generated by copying the image to `[FileSystem.documentDirectory]/previews/{localId}-thumb.jpg` (`generatePreview`).
    *   Metadata (`name`, `mimeType`, `thumbnailUri`, `status: 'pending'`, `createdAt`, `localId`) is saved to `metadata.json` within the file's local directory.
    *   The `localId` is added to a persistent queue file: `[FileSystem.documentDirectory]/sync_queue.json` (`addToSyncQueue`).
    *   The UI receives the `localId` and preview info to display the pending upload.

2.  **Background Sync (`startBackgroundSync` -> `processSyncQueue`):**
    *   A background task periodically reads `sync_queue.json`.
    *   It retrieves the next `localId` from the front of the queue.
    *   Reads the `metadata.json` and locates the actual image file within the `pending_uploads/{localId}/` directory.
    *   Calls `handleFileProcess` to initiate the upload and server processing.

3.  **Upload to Server (`handleFileProcess` -> `uploadFile`):**
    *   The image file content is read from its local path as a Base64 encoded string.
    *   A POST request is made to the backend endpoint `/api/upload`.
    *   The request includes authorization token, filename, mime type, and the Base64 content (`contentType: 'base64'`).
    *   The server handles the upload (e.g., to Vercel Blob) and returns a response containing `success: true`, a server-generated `fileId`, `status`, and the final `url`.

4.  **Server-Side Processing (`handleFileProcess` -> `processFile`):**
    *   A POST request is sent to `/api/process-file` with the `fileId` received from the upload step.
    *   This triggers backend processing relevant to the file type (e.g., OCR for images).

5.  **Polling for Results (`handleFileProcess` -> `pollForResults`):**
    *   The app periodically sends requests (polling) to status endpoints (e.g., `/api/files/{fileId}`, `/api/file-status`) using the `fileId`.
    *   Polling continues until the server response indicates `status: 'completed'` or `status: 'error'`, or a timeout occurs.

6.  **Finalization (`processSyncQueue`):**
    *   **On Success:** If polling returns `'completed'`, the local `metadata.json` is updated: `status` becomes `'completed'`, `serverFileId`, extracted `text` (if any), and `processedAt` timestamp are stored. The `localId` is removed from `sync_queue.json`****.
    *   **On Error:** If polling returns `'error'` or an error occurs during the process, the `metadata.json` is updated: `status` becomes `'error'`, the `error` message, and `lastAttempt` timestamp are stored. The `localId` is moved to the *end* of `sync_queue.json` for a later retry attempt.

## Key Files & Locations

*   **Core Logic:** `packages/mobile/utils/file-handler.ts`
*   **Local Storage (Pending):** `[FileSystem.documentDirectory]/pending_uploads/`
*   **Local Storage (Previews):** `[FileSystem.documentDirectory]/previews/`
*   **Sync Queue:** `[FileSystem.documentDirectory]/sync_queue.json`
*   **Server Endpoints:** `/api/upload`, `/api/process-file`, `/api/files/{id}`, `/api/file-status` (within `packages/web`)

## Future Considerations / Replication

To replicate this process, an AI agent would need to:
*   Understand how to interact with the device's file system (`expo-file-system`).
*   Manage the local directory structure (`pending_uploads`, `previews`).
*   Maintain the `sync_queue.json` state.
*   Read files as Base64.
*   Make authenticated API calls to the specified backend endpoints (`/api/upload`, `/api/process-file`, status endpoints).
*   Implement the polling logic to wait for server-side completion.
*   Handle both success and error states by updating local metadata and the sync queue appropriately. 